'''
    More Heat Than Light
    Jacob Wharton, Taylor Lundy, and John Beckman
'''


import pygame
import copy
import math
#import time
#import random
#import sys
#import os

    # CONST ######
MAXFPS = 60

WTYPE_GUN=0
WTYPE_MELEE=1

WEAP_PISTOL=0
WEAP_UZI=1
WEAP_SHOTGUN=2
WEAP_CLUB=3

AMMO_9MM=0
AMMO_SHELLS=1
AMMO_50CAL=2

DMG_TYPE_BULLET=0
DMG_TYPE_BLUNT=1
DMG_TYPE_SHARP=2
DMG_TYPE_LASER=3
DMG_TYPE_BIO=4
DMG_TYPE_NORMAL=99

MAP_WIDTH=1000
MAP_HEIGHT=1000
CAM_WIDTH=700
CAM_HEIGHT=700
SCREEN_WIDTH=700
SCREEN_HEIGHT=700



BLACK = (0,0,0)
WHITE = (255,255,255)
RED = (255,0,0)
GREEN = (0,255,0)
BLUE = (0,0,255)
    ##############

    # Load Assets #
SPR_pc = pygame.image.load('assets/player/mc.png')
SPR_enemy = pygame.image.load('assets/player/enemy.png')
SPR_enviro_car = pygame.image.load('assets/enviromentals/car.png')
SPR_weapon_pistol = pygame.image.load('assets/weapons/socom.png')
SPR_weapon_pistol_pickup = pygame.image.load('assets/weapons/socom_pickup.png')
SPR_projectile_9mm = pygame.image.load('assets/ammo/9mm.png')
SPR_projectile_50cal = pygame.image.load('assets/ammo/50cal.png')
    ###############

    # Init Pygame #
pygame.init()
pygame.display.set_caption('More Heat Than Light')










################################################################

                # Persistent Classes #

################################################################


class Observer: # "data": Global Datalists for runtime
    '''
    This object keeps track of lists of objects for reference
        by other objects.
    Each object with a step event, for example, must be placed
        on this list using the self.add() function,
        and removed when deleted using self.remove().

        Event names:
        
        ev_step             Performed every game frame
        ev_draw             Final event performed
        ev_collision        Event not performed automatically.
            Function ev_collision() must be explicitly called.
            Collisions will only be checked against other
            items in the list 'ev_collision'. All objects that
            can collide have to have an object BoxCollider
            called bbox.
    '''
    
    lists = {
        #"entities" : [],   # may be unnecessary...
        "dead" : [],    # entities to delete
        
        "shape" : [],
        
        "beginOfStep" : [],
        "step" : [],
        "endOfStep" : [],
        "draw" : [],
        "collision" : [],
            }

    def add(self, item, index):
        lis = self[index]
        if lis.count(item) == 0:
            lis.append(item)

    def remove(self, item, index):
        lis = self[index]
##        if lis.count(item) > 0:   # should never remove non-existant item
        lis.remove(item)

    def __getitem__(self,index):
        return self.lists[index]

    def __delattr__(self, name):
        pass

    def removeDeadThings(self):
        '''
            call to delete all entities in "dead" list
        '''
        deadStuff=[]
        for ent in self['dead']:
            deadStuff.append(ent)
        for ent in deadStuff:
            if isinstance(ent, Player):
                gameOver()
            else:
                self.remove(ent, 'dead')
            ent.cleanup(self)

        


class OrangIO: # "game": I/O Input and Output
    ''' NOTES
    This object takes input from Input class and handles
    events for all objects.
    
    perform_events() function:
    Iterate through list of events and also lists of objects
    Which have custom defined events like ev_step or ev_draw.
    To add a new event to an object, add the corresponding
    Event function (def ev_step, etc.) and put the following
    code in the __init__ and cleanup functions, respectively:
        data.add('ev_step', self)
        data.remove('ev_step', self)
    Replace ev_step with the event name if other than step.
    See Observer class for event names.
    '''
    
    events = None
    paused = False
    clock = pygame.time.Clock()
    suspended = False
    suspendAt_endOfTurn = False

    def __init__(self):
        data.add(self, 'step')
        self.init_keys()

    def cleanup(self):
        data.remove(self, 'step')

    def turn(self, value):
        # Handle the IO stream
    # While suspended, does not take Input or give Output.
    # Call with 'step' as argument to advance one frame then suspend IO.
        val = False
        if   value == 'off':
            val = True
        elif value == 'on':
            val = False
        elif value == 'step':
            val = False
            self.suspendAt_endOfTurn = True
        self.suspended = val
    
    def perform_events(self):
        if self.suspended == False:
            
            #####    PYGAME EVENTS    #####
            for ev in self.events:
                if ev.type == pygame.QUIT:
                    self.end()
                elif ev.type == pygame.MOUSEBUTTONDOWN:
                    mouseX,mouseY = pygame.mouse.get_pos()
                    if event.button == 1:   # left click
                        self.lmb = True
                        print("lmb pressed")
                    if event.button == 3:   # right click
                        self.rmb = True
                        print("rmb pressed")
                    if event.button == 2:   # middle click
                        self.mmb = True
                        print("mmb pressed")
            
            #####    CUSTOM EVENTS    #####
            
                # BEGIN OF STEP Event #
            for obj in data["beginOfStep"]:
                obj.ev_beginOfStep()
                
                # STEP Event #
            for obj in data["step"]:
                obj.ev_step()

                # END OF STEP Event #
            for obj in data["endOfStep"]:
                obj.ev_endOfStep()
            
                # DRAW Event #
            window.clear()
            window.queues_clear()
            
            for obj in data["draw"]:
                obj.ev_draw()
                
            window.queues_sortAll()
            window.draw()
            window.update()

            data.removeDeadThings()

##            print("going")
            if self.suspendAt_endOfTurn == True:
                self.suspendAt_endOfTurn = False
                self.suspended = True
##                print("worked")

    def init_keys(self):
        
        self.lmb = False
        self.rmb = False
        self.mmb = False
        
        self.k_space = False
        
        self.k_left = False
        self.k_right = False
        self.k_up = False
        self.k_down = False

    def get_input(self):
        if self.suspended == False:
            
            self.init_keys()
            self.keys = pygame.key.get_pressed()
            
            if self.keys[pygame.K_SPACE] == 1:
                self.k_space = True
                
            if self.keys[pygame.K_LEFT] == 1:
                self.k_left = True
            if self.keys[pygame.K_RIGHT] == 1:
                self.k_right = True
            if self.keys[pygame.K_UP] == 1:
                self.k_up = True
            if self.keys[pygame.K_DOWN] == 1:
                self.k_down = True

    def get_events(self):
        if self.suspended == False:
            self.events = pygame.event.get()

    def pause(self):
        self.paused = True

    def resume(self):
        self.paused = False

    def pause_toggle(self):
        self.paused = not(self.paused)
    
    def end(self):
        pygame.quit()
        quit()
    
    def ev_step(self):
        pass



class Window: # "window": GUI

        # Queue of objects to be drawn to the screen
    q = {
        'sprites' : []
        }

    def __init__(self, w, h):
        self.init_display(w, h)

    def init_display(self, w, h):
        self.DISP_W = w
        self.DISP_H = h
        self.disp = pygame.display.set_mode( (self.DISP_W,self.DISP_H) )

    def sprite(self, spr, x, y, z, rot=0, xscale=1,yscale=1  ):
        # transform sprite object into list of data
        self.q['sprites'].append(
            [spr, round(x), round(y), z, rot, xscale,yscale] )

    def queues_clear(self):         #<--''' ALTERED: TEST THIS CODE !!!!'''
        self.q['sprites'] = []

    def queue_sort(self, q):        #<--''' ALTERED: TEST THIS CODE !!!!'''
        # sort by depth (4th item in 'sprite' data created by Window.sprite())
        q = sorted(
             q, key=lambda item: item[3], reverse=True)
    
    def queues_sortAll(self):
        self.queue_sort(self.q["sprites"])
    
    def draw(self):     # Draw Screen
            # Shapes #
        for obj in data['shape']:
            if (  len(obj.vtx) > 2
            and   obj.visible == True  ):
                self.draw_poly( obj)
            # Sprites #
        for spr in self.q['sprites']:
            if (  spr[0] != None
            and   spr[0].visible == True  ):
                self.draw_sprite( spr)
    
    def draw_sprite(self, spr): # spr is struct from sprites list      
        image = spr[0].sprite  # pygame image
        xx = spr[1] - cam.x
        yy = spr[2] - cam.y
        if (spr[5] != 1 or spr[6] != 1):     # scale
            newW = spr[0].width * spr[5]
            newH = spr[0].height * spr[6]
            image = pygame.transform.scale(
                image, (newW,newH) )
        if spr[4] != 0:     # rotate
            image,newRect = self.rot_center(    # rotate image
                image, spr[0].width, spr[0].height, spr[4]
                )
        self.disp.blit(image, (xx, yy) )
    
    def draw_poly(self, poly):
        ptList = copy.deepcopy(poly.vtx)
        i = 0
        while i < len(ptList):
            ptList[i][0] += poly.x - cam.x
            ptList[i][1] += poly.y - cam.y
            i +=1
        pygame.draw.polygon(self.disp, poly.color, ptList)
        
    def clear(self):    # Clear Screen
        self.disp.fill(WHITE)

    def update(self):   # Refresh Screen
        pygame.display.update()

    def rot_center(self, image, width, height, angle): # angle in degrees
        """rotate an image while keeping its center"""
        rect = pygame.Rect(0,0, width, height)
        rot_image = pygame.transform.rotate(image, angle)
        rot_rect = rot_image.get_rect(center=rect.center)
        return rot_image,rot_rect
        





################################################################

                        # Other Classes #

################################################################



class Vector:
    D = 2   # Number of Dimensions
    
    def __init__(self, *args):
        if len(args) == 0: # UNTESTED CODE !!!!
            self.coord = [0,0]
        else:
            self.coord = flatten(args)

    def __getitem__(self,index):
        return self.coord[index]

    def __setitem__(self,index,value):
        self.coord[index] = value

    def __add__(self, val):     # Vector Addition
        ans = []
        for i in range(self.D): # val must have __getitem__
            ans.append(self[i] + val[i])
        return Vector(ans)

    def __iadd__(self, val):
        for i in range(self.D):
            self[i] += val[i]
        return self

    def __sub__(self, val):     # Vector Subtraction
        ans = []
        for i in range(self.D):
            ans.append(self[i] - val[i])
        return Vector(ans)

    def __isub__(self, val):
        for i in range(self.D):
            self[i] -= val[i]
        return self

    def __mul__(self, val):     # Scalar Multiplication
        ans = []
        for i in range(self.D):
            ans.append(self[i] * val)
        return Vector(ans)

    def __imul__(self, val):
        for i in range(self.D):
            self[i] *= val
        return self

    def __truediv__(self, val): # Scalar Division
        ans = []
        for i in range(self.D):
            ans.append(self[i] / val)
        return Vector(ans)

    def __itruediv__(self, val):
        for i in range(self.D):
            self[i] /= val
        return self
    
    def set(self, *args):       # Set Magnitude or set Coordinates
        if len(args) == 1:      # Pass in exactly one or D arguments respectively
            sz = self.mag
            if sz != 0:
                for i in range(self.D):
                    self[i] = ( self[i] / sz ) * args[0]
        else:
            i = 0
            for arg in args:
                self[i] = args[i]
                i +=1

    def setPolar(self, theta, radius):  # UNTESTED CODE !!!!
        self[0] =  math.cos(theta) * radius
        self[1] = -math.sin(theta) * radius

    def tuple(self):
        return ( self.x, self.y )

    def list(self):
        return list( self.tuple() )

    def copy(self):
        return Vector(self.x, self.y)

    @property 
    def radians(self):  # UNTESTED CODE !!!!
        return math.atan2(self[1], self[0]) + math.pi

    @property 
    def degrees(self):  # UNTESTED CODE !!!!
        return radtodeg(self.radians())

    @property 
    def x(self):
        return self[0]

    @property 
    def y(self):
        return self[1]

    @property 
    def mag(self):              # Get Magnitude
        return ( self.x**2 + self.y**2 ) **0.5


class Sprite:
    
    def __init__(self, owner, spr, xOff, yOff, w, h):
        self.owner = owner
        self.sprite = spr       # pygame image
        self.setDimensions(xOff, yOff, w, h)
        self.visible = True

    def setDimensions(self, xOff, yOff, w, h):
        self.x_offset = xOff
        self.y_offset = yOff
        self.width = w
        self.height = h

    def draw(self, *args):
        """
            draw a sprite
            pass 1 argument to send in just a rotation
                (use x, y, and depth from owner object)
            pass 3 args to send in x, y, and depth (rot=0)
            pass 4 args to send in x, y, depth, and rotation
        """
        x = self.owner.x
        y = self.owner.y
        rot=0
        depth=self.owner.depth
        if len(args) > 0:
            if len(args) == 1:
                rot = args[0]
            elif len(args) == 3:
                x               = args[0]
                y               = args[1]
                self.depth      = args[2]
            elif len(args) == 4:
                x               = args[0]
                y               = args[1]
                self.depth      = args[2]
                rot             = args[3]
        drawx = x - self.x_offset # after x has been (possibly) reset
        drawy = y - self.y_offset
        window.sprite(self, drawx, drawy, depth, rot)

    def draw_ext(self, x,y,depth, rot, xscale=1,yscale=1):
        """
            draw a sprite (extended version)
        """
        drawx = x - self.x_offset # after x has been (possibly) reset
        drawy = y - self.y_offset
        window.sprite(self, drawx, drawy, depth, rot)


class Shape:
    
    def __init__(self, xs, ys, *args):
        data.add(self, 'shape')
        
        self.color = BLACK
        self.x = xs
        self.y = ys
        self.vtx = []   # List of Vertices [x,y]
        for a in args:
            self.addVtx(a)
        self.visible = True

    def cleanup(self):
        data.remove(self, 'shape')

    def addVtx(self, *args):     # Add Vertex(es)
        for a in args:
            self.vtx.append(list(a))


class Shadowcaster:

    def __init__(self):
        pass

    
class BoxCollider:
    
    def __init__(self, owner=None, width=0, height=0):
        self.owner = owner
        self.follow()
        self.set_bbox(width, height, 0, 0)
        self.isSolid = False

    def cleanup(self):
        pass #data.remove(self, 'collision')

    def set_bbox(self, width, height, xOff, yOff):
        self.w = width
        self.h = height
        self.xOffset = xOff
        self.yOffset = yOff

    '''def overlaps(self, other): ##  Move to Owner then check a collision
        self.follow(self.owner)
        return collides(self,other)'''

    def place_free(self, xto, yto):
        '''
            Set collider position to xto, yto, then
            check if we would be colliding with Solid collider(s) there
            return True is place is free of collisions
        '''
        # (NOT) TODO: call follow function from within step event of objects with an instance of BoxCollider(?) NO PROBABLY NOT!!!!!!
        self.x = xto
        self.y = yto
        
        isFree = True
        for obj in data['collision']:
            if (  obj != self
            and   obj.isSolid == True
            and   self.collides(obj) == True  ):
                isFree = False
                break
        return isFree

    def position_meeting(self, x, y):
        '''
            Check if the position x,y is inside the box collider
            First move to the position of the owner if applicable
        '''
        self.follow()
        if (x >= self.x
        and x <= self.x + self.w
        and y >= self.y
        and y <= self.y + self.h ):
            return True
        else:
            return False
        
    def follow(self):
        if self.owner==None:
            return
        self.x = self.owner.x
        self.y = self.owner.y
    
    def collides(self,other): # Check at Current Position.
    #   other is BoxCollider
        if  (   self.x  <= other.x  + other.w
        and     self.x   + self.w  >= other.x
        and     self.y  <= other.y  + other.h
        and     self.y   + self.h  >= other.y   ):
            return True
        else:
            return False


class Camera:

    def __init__(self, x, y, width, height):
        data.add(self, "endOfStep")
        
        self.width = width
        self.heigh = height
        self.x = x
        self.y = y
        self.half_width = CAM_WIDTH / 2
        self.half_height = CAM_HEIGHT / 2

    def __del__(self):
        data.remove(self, "endOfStep")

    def set_position(self, x, y):
        self.x = x
        self.y = y

    def follow_character(self, character):
        self.x = character.x - self.half_width
        self.y = character.y - self.half_height
        if self.x < 0:
            self.x = 0
        if self.x > MAP_WIDTH- CAM_WIDTH:
            self.x = MAP_WIDTH - CAM_WIDTH
        if self.y < 0:
            self.y = 0
        if self.y > MAP_HEIGHT - CAM_HEIGHT:
            self.y = MAP_HEIGHT - CAM_HEIGHT

    def ev_endOfStep(self):
        self.follow_character(game.pc)
        



#####################################
########   GAME CLASSES     ###########
#####################################



class Mobile:

    def __init__(self):
##        data.add(self, 'step')
        
        super(Mobile, self).__init__()
        self.bbox = None # Bounding Box (Collider)
        self.x = 0
        self.y = 0
        self.speed = Vector([0,0])
        
    def cleanup(self):
        pass
##        data.remove(self, 'step')
            
    def move(self): # Move X and Y based on speed Vector
        if self.speed.mag != 0:
            xSpd = self.speed.x
            ySpd = self.speed.y
            
            if self.bbox != None:
                if self.bbox.place_free(
                    self.x + xSpd, self.y ) == True:
                    self.x += xSpd
                if self.bbox.place_free(
                    self.x, self.y + ySpd ) == True:
                    self.y += ySpd
            else:
                self.x += xSpd
                self.y += ySpd

    def jumpTo(self, xto, yto):
        self.x = xto
        self.y = yto

    def ev_step(self):
        if game.paused == False:
            self.move()


class Entity:
    
    def __init__(self):
        super(Entity, self).__init__()
        self.x=0
        self.y=0
        self.depth=0
        self.hp=0
        self.hpMax=0
        self.isDead=False
        self.isSolid=False
        self.rotation=0
        






## NEW CODE

        
################################################################

                            # COMBAT #

################################################################

'''
    changes to existing codebase needed to implement Combat:
        - OrangIO: added lmb,rmb,mmb, changed perform_events func
        - added to BoxCollider: position_meeting() func
        - give hp variable to enemy and all things that need it
        - everything that collides needs to add itself to data['collision']
            * it also must have a bbox variable (BoxCollider instance)
            * it does NOT need to have an ev_collision function
            * for now, if it wants to executs code on collision
            with certain objects, it calls the following code in ev_step:
                collision_check(self)
            and executes code on other in ev_collision().
        - Player: added new vars, new functions, updated ev_step
        - added vars to Entity class
        - changed ev_collision
            * collides is the new name for what was ev_collision
            * now we have the collision events accept an other object parametre
        - created MAXFPS const = 60, use it in main function
            - created weapon ID constants, ammo consts...
        - added "dead" key to Observer class lists dict
        - added removeDeadThings func to Observer class
        - changed __del__ functions for all classes to the name "cleanup"
            * using __del__ was a mistake and would produce a bug.
        - updated Vector class
            added func: degrees, copy
        - changed Mobile class:
            * no parent classes should add themselves to data
        - changed window to have rotation capability (new func, updated sprite draw func)        
    
'''
            


class Bullet(Entity, Mobile):
    def __init__(self,
                 _bSpr, _x, _y, _v, _dmg, _dType,
                 _rng, _aoe, _pierce, _t, _bboxSize
                 ):
        data.add(self, "step")
        data.add(self, "draw")
        data.add(self, 'collision')     # it can collide with other things
                
        super(Bullet, self).__init__()
        self.isDead=False
        self.sprite = Sprite(self, _bSpr, 16, 16, 32, 32)
        self.x=_x
        self.y=_y
        self.startX=_x
        self.startY=_y
        self.speed=_v
        self.damage=_dmg
        self.damageType=_dType
        self.maxRange=_rng
        self.maxTime=_t
        self.time=0
        self.sprite = Sprite(self, SPR_projectile_9mm)
        self.bbox = BoxCollider(self, _bboxSize, _bboxSize)
        
    def cleanup(self, data):
        data.remove(self, 'step')
        data.remove(self, 'draw')
        data.remove(self, 'collision')
        
    def ev_step(self):
        super(Bullet,self).ev_step()
        #if game.paused==False:
        self.time += 1
        if (
            self.time > self.maxTime
            or distance(self.x,self.y,self.startX,self.startY) > self.maxRange
            ):
            kill(self)
            return

    def ev_draw(self):
        self.sprite.draw(radtodeg(self.speed.radians))

    def ev_collision(self, other):
        pass


# class for things that can shoot guns, swing bats, etc.
class Fighter:
    GUN=0
    MELEE=1
    STATE_NORMAL = 0
    STATE_RELOADING = 1
    STATE_SWINGING = 2      # swinging melee weapon
##    STATE_SWAPPING = 3      # swapping weapons
##    STATE_FIRING = 10
    
    def __init__(self):
        print(self, "Inherited from Fighter")
        
        self.weap=None      # equipped weapon
        self.weapType = None # type of equipped weapon
        self._autoReload = 0
        self._reloading = 0
        self._state = Fighter.STATE_NORMAL

    def cleanup(self):
        pass

    def ev_step(self):
        print(self, "called Shooter ev_step function")
        
        # reloading
        self._autoReload -= 1
        self._reloading -= 1
        if self._autoReload == 0:
            self.reload()
        if self._reloading == 0:
            self._reload()
    
    def fire(self, tvector):
        '''
            (attempt to) fire the gun with the trajectory Vector tvector
                initiate reloading sequence if out of ammo
        '''
        if self._state == Fighter.STATE_NORMAL:
            if self.weap == None:  # can't fire fists
                return
            if self.weapType == WTYPE_MELEE:  # can't fire swords
                return
            if self.weap.ammo > 0:
                self.weap.pressTrigger(tvector)
            else:
                self._click_reload()
        else:
            if self._state == Fighter.STATE_RELOADING:
                self._click()
    
    def reload(self):
        '''
            begin reloading sequence
        '''
        # animation
        # TODO: animations
        # timer
        self._reloading = self.weap.reloadTime
        # change state to reloading
        self._state = Fighter.STATE_RELOADING
       
    def _click(self): # try to fire with empty mag, just play a sound
        pass
    
    def _click_reload(self): # try to fire with empty mag, auto-reload
##        sounds.play(SND_GUN_CLICK)    # TODO: sounds. Could be imported in a file called sounds.py which contains functions for playing sounds etc.
        self._autoReload = 15   # wait a few frames to auto-reload
    
    def _reload(self):  # call gun's reload func to refill ammo
        self.weap.reload()
    
    def _interruptReload(self): # call to stop the reloading sequence
        self._reloading = 0
        self._autoReload = 0
        # cancel animation
        self._state = Fighter.STATE_NORMAL



class Weap_Pickup:
    def __init__(self, weapObj, x, y):
        data.add(self, 'draw')
        data.add(self, 'collision')
        
        self._weap_object = weapObj
        self.x=x
        self.y=y
        self.depth=0
        self.bbox = BoxCollider(16,16)
        
        # pick a sprite based on the ID
        if _weap_object.ID==WEAP_PISTOL:
            self.sprite=Sprite(
                SPR_weapon_pistol_pickup, 128,128, 256,256
                )

    def cleanup(self):
        data.remove(self, 'draw')
        data.remove(self, 'collision')

    def get(self, ent):
        equip_weap(ent, self._weap_object)
        
    def ev_draw(self):
        self.sprite.draw_ext(self.x, self.y, self.depth, 0, 0.25, 0.25)
# example: item=Weap_Pickup(Pistol())



class Gun:
    MODE_SEMI=0
    MODE_AUTO=1
    MODE_BURST=2
    
    def __init__(self,
                 name, ID, dSprite, bSprite, aType,
                 dmgm, dmg, dType, acc, rof, magSize, rTime,
                 bSpeed, bSpeedMax, bLife, bLifeMax,
                 kick=0, pierces=0, burstn=3, aoe=0, shots=1, spread=0, 
                 semi=True, auto=False, burst=False, safe=False
                 ):
        # new parameters: kick, safe        
        super(Gun, self).__init__()
        
        self.name = name
        self.ID = ID
##        self.sprite = sprite            # player's sprite when pickup weapon
        self.dispSprite = dSprite       # display sprite (for menus, HUD, etc.)
        self.bulletSprite = bSprite     # sprite of the bullet it fires
        self.ammoType = aType           # what kind of ammunition it uses
        self.damageMelee = dmgm         # health damage dealt with melee
        self.damage = dmg               # health damage dealt with bullet
        self.damageType = dType         # Damage type constant
        self.accuracy = acc             # 100 is perfect accuracy -> mousepos
        self.areaOfEffect = aoe         # pixel radius
        self.rateOfFire = rof           # shots per second
        self.shotsFired = shots         # quantity of missiles fired per shot
        self.shotSpread = spread        # shot spread amount for multishots
        self.magSize = magSize          # ammo capacity
        self.reloadTime = rTime         # game ticks elapsed when reloading
        self.bulletSpeed = bSpeed       # minimum speed the bullet moves
        self.bulletSpeedMax = bSpeedMax # maximum "
        self.bulletLife = bLife         # game ticks elapsed before autodeath
        self.bulletLifeMax = bLifeMax   # maximum "
        self.bulletDistance = 9999
        self.bulletDistanceMax = 9999
        self.kick = kick                # kickback amount
        self.pierces = pierces          # how many foes it can pierce
        self.burstQuantity = burstn     # how many shots fired in burstfire
        self.mode_semi=semi             # can it fire semiauto?
        self.mode_auto=auto             # " automatic?
        self.mode_burst=burst           # " burst fire?
        self.has_safety = safe          # does it have a wimpy safety mode?
        
        self.mode = Gun.MODE_SEMI       # current fire mode setting
        self.safety=False               # safety mode on?
        self.ammo=0                     # number of shots currently chambered
        self.can_fire=True
        
    def safety_toggle(self):    self.safety = not self.safety
    def mode_set_semi(self):    self.mode = Gun.MODE_SEMI
    def mode_set_auto(self):    self.mode = Gun.MODE_AUTO
    def mode_set_burst(self):   self.mode = Gun.MODE_BURST
    
    def reload(self):
        # TODO: implement limited ammo restraints
        self.ammo = self.magSize
    
    def pressTrigger(self, tvector):    # fire, aimed with trajectory tvector
        if self.wait > 0: return
        if self.safety: return
        if self.mode == Gun.MODE_SEMI:
            self._fireSemi(tvector)
        elif self.mode == Gun.MODE_BURST:
            self._fireBurst(tvector)
        elif self.mode == Gun.MODE_AUTO:
            self._fireAuto(tvector)
    
    def releaseTrigger(self):
        # release the "fire" button to allow another semi-auto shot
        self.can_fire = True
        
    def _calcShotDelay(self):
        ''' Calculate & return the number of steps before you can fire again.
            Delay time is based on framerate and rate of fire. '''
        return (MAXFPS / self.rateOfFire)
    
    def _fireSemi(self, tvector):   # semi-auto fire
        #   Note: can_fire must be reset before you can fire again
        #   ( you have to release the trigger before you can pull it again )
        self.wait = self._calcShotDelay()
        self.can_fire = False
        self._fire(tvector)
    
    def _fireAuto(self, tvector):   # full auto fire
        self.wait = self._calcShotDelay()
        self._fire(tvector)
    
    def _fireBurst(self, tvector):  # burst fire
        pass
    
    def _fire(self, tvector):       # release a shot
        life = self.bulletLife + int(
            random.random(self.bulletLifeMax - self.bulletLife)
            )
        rng = self.bulletDistance + int(
            random.random(self.self.bulletDistanceMax - self.bulletDistance)
            )
        angle_diff = random.random(100 - self.accuracy)
        newVector = tvector.copy()
        newVector.setPolar(
            vector.radians + angle_diff, self.bulletSpeed + int(
                random.random(self.bulletSpeedMax - self.bulletSpeed) )
            )
        for ii in range(self.shotsFired):
            tempVector = tvector.copy()
            tempVector.setPolar(newVector.radians, self.bulletSpeed + int(
                random.random(self.bulletSpeedMax - self.bulletSpeed)
                ))
            bullet = Bullet(
                self.bulletSprite,
                self.x, self.y, newVector,
                self.damage, self.damageType, rng,
                self.areaOfEffect, self.pierces, life, 4,
                )


'''
    def __init__(self,
                 name, dSprite, bSprite, aType,
                 dmgm, dmg, dType, acc, rof, magSize, rTime,
                 bSpeed, bSpeedMax, bLife, bLifeMax,
                 kick=0, pierces=0, burstn=3, aoe=0, shots=1, spread=0, 
                 semi=True, auto=False, burst=False, safe=False
                 ):'''
        
class Pistol(Gun):
    def __init__(self):
        dSpr = Sprite(self, SPR_weapon_pistol_pickup, 128,128, 256,256)
        bSpr = Sprite(self, SPR_projectile_9mm, 16,16, 32,32)
        super(Pistol, self).__init__(
            "Pistol", dSpr, bSpr, AMMO_9MM,
            25, 20, DMG_TYPE_BULLET, 96, 3, 12, 120,
            25, 28, 180, 180,
            safe=True
            )
        
##class Shotgun(Gun):
##    def __init__(self):
##        dSpr = Sprite(self, SPR_weapon_shotgun_pickup, 128,128, 256,256)
##        bSpr = Sprite(self, SPR_projectile_shell, 16,16, 32,32)
##        super(Shotgun, self).__init__(
##            "Shotgun", dSpr, bSpr, AMMO_SHELLS,
##            36, 10, DMG_TYPE_BULLET, 95, 1, 6, 180,
##            18, 22, 120, 120,
##            kick=3, shots=5, spread=15
##            )
    

        
            
    
def radtodeg(rads): return rads*180/math.pi
def degtorad(degs): return degs*math.pi/180
def distance(x1,y1,x2,y2): return math.sqrt((x2-x1)**2 + (y2-y1)**2)
def direction(x1,y1,x2,y2): return math.atan2(y2-y1, x2-x1)

def rayCast(x1,y1,x2,y2, delim):    # NOT WORKING!!!
    '''
        cast a ray that moves by delim pixels per step.
        When it reaches its destination it returns True,
        or when it finds a Solid collider on its path, returns False.
    '''
    vector = Vector(0, 0)
    goal = Vector(x2-x1, y2-y1)
    angle = direction(x1,y1,x2,y2)
    startDist = distance(x1,y1,x2,y2)
    while startDist - vector.mag >= delim:
        vector.setPolar(vector.mag + delim, angle)
        print(vector.x,vector.y)
        for other in data['collision']:
            if (other.isSolid
            and other.position_meeting(x1 + vector.x, y1 + vector.y) ):
                print("False...")
                return False
    print("True...")
    return True

def gameOver():
    #TODO: show "YOU DIED" sequence or some shit
    game.end()

def hurt(ent, damage, damageType=DMG_TYPE_NORMAL):
    if ent.isDead: return
    ent.hp -= damage
    if ent.hp <= 0:
        kill(ent)

def kill(ent):
    data.add(ent, "dead") 
    ent.isDead = True

def equip_weapon(ent, weap):
    ent.weap = weap

def collision_check(self):
    '''Perform collision event on all objects we are colliding with'''
    for other in data['collision']:
        if self.bbox.collides(other.bbox):
            self.ev_collision(other)
    
# create weapon functions
def create_pistol(x, y):
    weap = Weap_Pickup(WEAP_PISTOL, x, y)
    return weap
def create_uzi(x, y):
    weap = Weap_Pickup(WEAP_UZI, x, y)
    return weap
def create_shotgun(x, y):
    weap = Weap_Pickup(WEAP_SHOTGUN, x, y)
    return weap
def create_club(x, y):
    weap = Weap_Pickup(WEAP_CLUB, x, y)
    return weap


 ## /NEW CODE











class Player(Entity, Mobile, Fighter):
    STATE_STANDING=0
    STATE_WALKING=1
    STATE_DASHING=2
    
    def __init__(self, x, y):
        data.add(self, 'step')
        data.add(self, 'draw')
        data.add(self, 'collision')
        
        super(Player, self).__init__()
        self.state = Player.STATE_STANDING
        self.isDead=False
        self.rotation=0
            # Load PC Variables
        self.hp             = 100
        self.hpMax          = self.hp
        self.x              = x
        self.y              = y
        self.accel          = 1
        self.maxSpd         = 8
        self.friction       = .5
        self.sprite         = Sprite(self, SPR_pc, 16,16, 32,32)
        self.depth          = -10000
        self.dash_speed     = 10
        self.dash_time      = 5
        self.dash_cooldownMax = 15
        self.dash_cooldown  = 0
        self.dashing        = 0
        self.dash_iframes   = 4
        self.iframes        = 0
        self.bbox = BoxCollider( self, self.sprite.width,
                                       self.sprite.height )
        
    def cleanup(self):
        data.remove(self, 'step')
        data.remove(self, 'draw')
        data.remove(self, 'collision')
    
    def input(self):
        # get a vector based on the move key inputs from the player
        mov = Vector( -game.k_left + game.k_right,
                      -game.k_up   + game.k_down   )
        # acceleration
        if mov.mag > 0:
            mov.set(self.accel)
            self.speed += mov
            # dashing
            if (game.k_space==True and self.dash_cooldown < 0):
                self.dash(mov)
        # rotation / aiming
        mouseX,mouseY = pygame.mouse.get_pos()
        self.rotation = -radtodeg(direction(self.x,self.y, mouseX, mouseY))
    
    def ev_step(self):
        if game.paused == False:
            self.upkeep()
            self.input()
                # Collision checking - temporary code
            for other in data['collision']:
                if self.bbox.collides(other.bbox):
                    self.ev_collision(other)
                # Max Speed
            if self.state != Player.STATE_DASHING:
                self.speed.set(
                    min(self.speed.mag, self.maxSpd) )
                # Friction
            if self.state != Player.STATE_DASHING:
                self.speed.set(
                    max(0, self.speed.mag - self.friction) )
                # Animation
            if self.state != Player.STATE_DASHING:
                if self.speed.mag >= 0.25:
                    self.state = Player.STATE_WALKING
                else:
                    self.state = Player.STATE_STANDING      
            # super call
            super(Player, self).ev_step()            
    
    def ev_draw(self):
        self.sprite.draw(self.rotation)
    
    def ev_collision(self, other): # called manually...
        if isinstance(other, Enemy):
            hurt(self, other.damage, DMG_TYPE_BLUNT)
        elif isinstance(other, Bullet):
            hurt(self, other.damage, other.damageType)
            if other.pierces:
                other.pierces -= 1
                self.iframes = 3    # temporary value
            else:
                kill(other)
        elif isinstance(other, Weap_Pickup):
            other.get(self)
            kill(other)
    
    def upkeep(self):
        self.dash_cooldown  -= 1
        self.dashing        -= 1
        self.iframes        -= 1
        if (self.state==Player.STATE_DASHING and self.dashing < 0):
            self.reset_state()
        if self.iframes < 0:
            self.invincible = False
    
    def resetState(self):
        self.state = Player.STATE_STANDING
        # reset sprite?
        
    def dash(self, mov):
        #self.sprite = SPR_PLAYER_DASHING
        self.invincible = True
        self.iframes = max(self.dash_iframes, self.iframes)
        self.state = Player.STATE_DASHING
        self.speed = mov * self.dash_speed
        self.dash_cooldown = self.dash_cooldownMax
        self.dashing = self.dash_time



class Enemy(Entity, Mobile):

    def __init__(self, xpos, ypos):
        data.add(self, 'step')
        data.add(self, 'draw')
        
        super(Enemy, self).__init__()
            # Load PC Variables
        self.x              = xpos
        self.y              = ypos
        self.isDead         = False
        self.accel          = 1
        self.maxSpd         = 4
        self.friction       = .5
        self.sprite         = Sprite(self, SPR_enemy, 16, 16, 32, 32)
        self.sprite_current = self.sprite
        self.depth          = -9
        self.invincible     = False
        self.iframes        = 0
        self.targetInSight  = False
        self.bbox = BoxCollider( self, self.sprite.width,
                                       self.sprite.height )

    def __del__(self):
        data.remove(self, 'step')
        data.remove(self, 'draw')    

    def lineOfSight(self):
        targetDX = game.pc.x - self.x
        targetDY = game.pc.y - self.y

        self.targetAngle = math.degrees(math.atan(targetDY / targetDX))

        self.targetDist = math.sqrt(targetDX**2 + targetDY**2)

    def follow(self):
        self.lineOfSight()

        if self.targetDist < 300:
            self.targetInSight = True
            
        if self.targetDist > 100 and self.targetInSight == True:
            self.speed.setPolar(-self.targetAngle, self.maxSpd)

        if self.targetDist < 25:
            self.speed = Vector(0, 0)
            
            
    def ev_step(self):
        self.follow()
        # Max Speed
        self.speed.set(
            min(self.speed.mag, self.maxSpd) )
        # Friction
        self.speed.set(
            max(0, self.speed.mag - self.friction) )

        super(Enemy, self).ev_step()

    def ev_draw(self):
        self.sprite_current.draw()



class SpawnPoint():
    
    def __init__(self, x, y):
        data.add(self, 'step')
        self.x = x
        self.y = y

    def cleanup(self):
        data.remove(self, 'step')

    def spawn(self):
        enemy = Enemy(self.x, self.y)
        return enemy

    def ev_step(self):
        if random.randrange(10000) < 1:
            self.spawn()




################################################################

                        # FUNCTIONS #

################################################################



def flatten(*args):
    ans = []
    for arg in args:
        if hasattr(arg, '__iter__'):
            ans.extend(flatten(*arg))
        else:
            ans.append(arg)
    return ans


##def create_player(): # not needed anymore
##    pc = Player(data)
##    return pc









################################################################

                            # MAIN #

################################################################
        

def main(*args):
    
        # INIT GAME ##
    gameRunning = True
##    window.init_display(700,700)
    
        ## Init Objects
    pc = Player(150, 250)
    game.pc = pc

        ##### TESTING PURPOSES ONLY
    
##    rayCast(16, 26, 477, 724, 1)
##    rayCast(16, 26, 477, 724, 3)
##    rayCast(16, 26, 477, 724, 5)
##    rayCast(16, 26, 477, 724, 7)
##    rayCast(0,0,100,100,15)
    
    Shape(200, 200, [0,0],     [120,50], [40,150] ).color = RED
    Shape(10, 50, (-50,20),  (40,190), (30,250) )
    Shape(500, 300, (-50,100), (190,0), (200,100), (400,250) )
    bill = Shape( 40, 40, (0, 0), (0, 120), (120, 120), (120, 0) )
    box1 = BoxCollider(bill, 120, 120)
    box1.solid = True
    bob = Shape( 400, 40, (0, 0), (0, 120), (120, 120), (120, 0) )
    box2 = BoxCollider(bob, 120, 120)
    box2.solid = True
    Shape(40, 20)
    del bob

    u = -1
        #####

    
# MAIN GAME LOOP #
    while gameRunning:
        game.clock.tick(MAXFPS)
        game.get_input()
        game.get_events()
        game.perform_events()




                    # PROGRAM #

##if __name__ == "__main__":        

data = Observer()
game = OrangIO()
window = Window(SCREEN_WIDTH, SCREEN_HEIGHT)
cam = Camera(0, 0, CAM_WIDTH, CAM_HEIGHT)

main()
game.end()


################################################################



